/**
 * Escrito por Antonio Barros e Lucas Emanuel em Novembro/2018
 */
exports.solve = function (fileName) {
  let formula = readFormula(fileName)
  let result = doSolve(formula.clauses, formula.variables)
  return result
}

function nextAssignment(assignment) {
  for (let aux = 0; aux < assignment.length; aux++) {
    if (!assignment[aux]) {
      assignment[aux] = !assignment[aux]
      return assignment // apos trocar um false para true, retorna uma nova atribuicao
    } else {
      assignment[aux] = !assignment[aux] // se o atributo no momento da analise, e verdadeiro, o valor do mesmo e alterado    
    }
  } return 0 //se nao entrar no if em nenhum caso significa que todos sao verdadeiros
  // se todos sao verdadeiros todos os casos ja foram testados
}

function doSolve(clauses, assignment) {
  let isSat = false
  let last = false
  let lineP = true
  if (clauses.length <= 0) {
    lineP = false // se for encontrado erro no CheckProblemSpecification, nao entrara no while 
  }
  while (!isSat && !last && lineP) {
    let checkClause = true // variavel é atribuida como true, para se o for parar com o i < length, ela ser verdade, pois isso significaria que todas sao verdadeiras.
    for (let i = 0; i < clauses.length && checkClause; i++) {
      checkClause = false // atribuida para false pelos mesmos motivos, mas nao poder ter o mesmo valor, para nao parar os dois for
      for (let j = 0; j < clauses[i].length && !checkClause; j++) {
        let variable = clauses[i][j]
        let booleanVar = assignment[Math.abs(variable) - 1] // atruibui para a variavel booleana, o valor daquela variavel analisada, retirado do array das atribuicoes
        if (variable < 0 && booleanVar == false || variable > 0 && booleanVar == true) {
          checkClause = true // quanela recebe o true nessa linha, significa que algum elemento da clausula, relacionado com as possiveis variaveis atuais, ja é true, e como dentro da clausula temos apenas (ou) ele deve parar o primeio for, e ir para a proxima clausula
        } // para alguma clausula que nao seja true a variavel segue como false e para o for inicial
      }
    }
    if (checkClause) { // sendo ela true, entao foi achado um valor parar as variaveis que torna todas as clausulas verdadeiras
      isSat = true //entao o while para com o isSat 
    } else {
      assignment = nextAssignment(assignment)
    }
    if (assignment == 0) { // se o assignment for 0, entao todas as possibilidades ja foram testadas
      last = true // nesse caso o while sera parardo pelo last, e o isSat segue como falso
    }
  }

  let result = { 'isSat': isSat, satisfyingAssignment: null }
  if (isSat) {
    result.satisfyingAssignment = assignment // sendo sat o assignment é armazenado
  }
  return result // caso nao seja sat, no resultado teremos false e null
}

function readFormula(fileName) {// implementacao do codigo de leitura (lendo o arquivo)
  const fs = require('fs')
  let text = fs.readFileSync(fileName, 'utf8').split(/[\r\n]+/) // lendo arquivo e cria um array com cada pedaco do texto em indices de um array
  let clauses = readClauses(text) // chama a funcao criada ´para separar as clausulas
  let variables = readVariables(clauses) // chama a funcao criada para armazenar as variaveis
  let specOk = checkProblemSpecification(text, clauses, variables) // chama a funcao que ira analisar se a linha p nao tem erros
  let result = { 'clauses': [], 'variables': [] }
  if (specOk) {
    result.clauses = clauses
    result.variables = variables
  } // caso a linha p nao tenha erros o result recebe as clausulas e as variaveis
  return result
}

function readClauses(text) {
  let textAux = []
  for (let aux = 0; aux < text.length; aux++) {
    if (text[aux].charAt(0) == 'c' || text[aux].charAt(0) == 'p' || text[aux].charAt(0) == '') {
      continue
    } else {
      textAux.push(text[aux]) // adiciona em um array auxiliar apenas os arrays que contem as variaveis
    }
  }
  textAux = textAux.join(' ') // fica tudo agrupado em apenas um so text (evitando o problema de a linha nao terminar com o 0)
  textAux = textAux.split(' 0 ') // cria-se um novo array divido no 0
  let result = []
  for (let i = 0; i < textAux.length; i++) {
    result[i] = textAux[i].split(' ')
    if (i == textAux.length - 1) {
      result[i].pop()
    }
    for (let j = 0; j < result[i].length; j++) {
      result[i][j] = parseInt(result[i][j]) // e necessario que esteja em "int" para sabermos quem é negativo ou positivo
    }
  }

  return result
}

function readVariables(clauses) {
  let variables = []
  for (let i = 0; i < clauses.length; i++) {
    for (let j = 0; j < clauses[i].length; j++) {
      for (let aux = variables.length; clauses[i][j] > aux; aux++) {
        variables.push(false) // armazena variaveis em um array de tamanho igual ao maior numero encontrado
      }
    }
  }
  return variables
}

function checkProblemSpecification(text, clauses, variables) {
  let auxP = [] // array que vai receber, o array que contem a linha P
  let hasP = false
  for (let aux = 0; aux < text.length && !hasP; aux++) {
    if (text[aux].charAt(0) == 'p') {
      auxP = text[aux].split(' ')
      hasP = true // para o for ao encontrar a linha p
    }
  }
  if (hasP) {
    let variablesLengthP = parseInt(auxP[2]) // como a linha p sempre e escrita do mesmo jeito entao nas posicoes 2 e 3 do array
    let clausesLengthP = parseInt(auxP[3]) // sempre vai conter o numero de "Variaveis x numero de Clauses"
    if (variablesLengthP === variables.length && clausesLengthP === clauses.length) {
      return true // se as especificacoes da linha P baterem com o que tinha declarado nas linhas abaixado do texto
    } else {
      return false
    }
  } else {
    return true;
  }
}