/**
 * Escrito por Antonio Barros e Lucas Emanuel em Novembro/2018
 */
exports.solve = function(fileName) {
    let formula = readFormula(fileName)
    let result = doSolve(formula.clauses, formula.variables)
    return result 
  }
  
  function nextAssignment(assignment) {
   for (let aux = 0; aux < assignment.length; aux++){
     if (!assignment[aux]){
      assignment[aux] = !assignment[aux]
      return assignment // apos trocar um false para true, retorna uma nova atribuicao
     } else {
      assignment[aux] = !assignment[aux] // se o atributo no momento da analise, e verdadeiro, o valor do mesmo e alterado    
     }
   } return 0 //se nao entrar no if em nenhum caso significa que todos sao verdadeiros
   // se todos sao verdadeiros todos os casos ja foram testados
  }
  
  function doSolve(clauses, assignment) {
    let isSat = false
    let last = false
    while (!isSat && !last) {
    let checkClause = true
      for (let i = 0; i < clauses.length && checkClause; i++){
        checkClause = false
        for (let j = 0; j < clauses[i].length && !checkClause; j++){
          let variable = clauses[i][j]
          let booleanVar = assignment[Math.abs(variable) - 1] // atruibui para a variavel booleana, o valor daquela variavel analisada, retirado do array das atribuicoes
          if (variable < 0 && booleanVar == false || variable > 0 && booleanVar == true){
            checkClause = true
          }
        }
      }
      if (checkClause){
        isSat = true
      } else {
        assignment = nextAssignment(assignment)
      }
      if (assignment == 0){ // se o assignment for 0, entao todas as possibilidades ja foram testadas
        last = true
      }
    }
    let result = {'isSat': isSat, satisfyingAssignment: null}
    if (isSat) {
      result.satisfyingAssignment = assignment
    }
    return result
  }
    
  function readFormula(fileName) {// implementacao do codigo de leitura (lendo o arquivo)
    const fs = require('fs')
    let text = fs.readFileSync(fileName, 'utf8').split(/[\r\n]+/) // lendo arquivo e cria um array com cada pedaco do texto em indices de um array
    let clauses = readClauses(text)
    let variables = readVariables(clauses)
    let specOk = checkProblemSpecification(text, clauses, variables)
    let result = { 'clauses': [], 'variables': [] }
    if (specOk) {
      result.clauses = clauses
      result.variables = variables
    }
    return result
  }
  
  function readClauses(text) {
    let textAux = []
    for (let aux = 0; aux < text.length; aux++) {
      if (text[aux].charAt(0) == 'c' || text[aux].charAt(0) == 'p' || text[aux].charAt(0) == '') {
        continue
      } else {
        textAux.push(text[aux]) // adiciona em um array auxiliar apenas os arrays que contem as variaveis
      }
    }
    textAux = textAux.join (' ') // fica tudo agrupado em apenas um so text (evitando o problema de a linha nao terminar com o 0)
    textAux = textAux.split (' 0 ') // cria-se um novo array divido no 0
    let result  = []
    for (let i = 0; i < textAux.length; i++) {
      result[i] = textAux[i].split(' ')
      if (i == textAux.length - 1){
        result[i].pop()
      }    
      for (let j = 0; j < result[i].length; j++) {
            result[i][j] = parseInt(result[i][j]) // e necessario que esteja em "int" para sabermos quem Ã© negativo ou positivo
        }
    } 

    return result
  } 
  
  function readVariables(clauses) {
    let variables = []
    for (let i = 0; i < clauses.length; i++) {
        for (let j = 0; j < clauses[i].length; j++) {
          for (let aux = variables.length; clauses[i][j] > aux; aux++) {
            variables.push(false)
          }
        }
    }
    return variables
  }
  
  function checkProblemSpecification (text, clauses, variables) {
    let auxP = [] // array que vai receber, o array que contem a linha P
    let hasP = false
    for (let aux = 0; aux < text.length && hasP; aux++) {
      if (text[aux].charAt(0) === 'p') {
        auxP = text[aux].split(' ')
        hasP = true // para o for ao encontrar a linha p
      } 
    } 
    if (!hasP){
      return true
    } 
    let variablesLengthP = parseInt(auxP[2]) // como a linha p sempre e escrita do mesmo jeito entao nas posicoes 2 e 3 do array
    let clausesLengthP = parseInt(auxP[3]) // sempre vai conter o numero de "Variaveis x numero de Clauses"
    if (variablesLengthP === variables.length || clausesLengthP === clauses.length) {
      return true // se as especificacoes da linha P baterem com o que tinha declarado nas linhas abaixado do texto
    } else {
      return false;
    }
  }